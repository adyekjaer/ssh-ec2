#!/usr/bin/env python
import os
import sys
import boto.ec2
import getopt
import pickle
import time
import subprocess
import shlex
import re

# Global cache file
cache_file='/tmp/ssh-ec2.cache'

def check_cache():
    if not ( os.path.isfile(cache_file) ):
        populate_cache()

    # Calculate file age
    stat = os.stat(cache_file)
    fileage = int(stat.st_mtime)
    now = int(time.time())
    delta = now - fileage

    if (delta > 172800 ):
        populate_cache()
        return True
    else:
        return False

def populate_cache():
 
    print >>sys.stderr, 'Please wait while we populate the cache'

    # Open file for writing
    cache_file_fh = open(cache_file, 'w+')

    cache = []

    list_of_tag_keys=[]
    instances_and_tags={}
    instances_and_name={}
    instances_and_dns={}
    server_count=0

    regions = boto.ec2.regions()

    for region in regions:

        print 'Walking region ' + str(region.name)

        conn = region.connect()
        reservations = conn.get_all_instances()
        tags=conn.get_all_tags()

        for tag_object in tags:
            tag = str(tag_object).split(':')[1]
            if tag not in list_of_tag_keys:
                list_of_tag_keys.append(tag)

        for reservation in reservations:
            for instance in reservation.instances:
                if instance.state == 'terminated':
                    continue
                instances_and_tags[instance.id]=[]
                instances_and_dns[instance.id]=instance.public_dns_name

                # For each tag we check if server has it
                for key in list_of_tag_keys:
        
                    if key.lower() == 'name':
                        instances_and_name[instance.id]=instance.tags.get(key).lower()

                    # Does this server have the tag
                    if key in instance.tags:
                        value = instance.tags.get(key).lower()

                        # Populate a dict of instance ids with associated tags
                        instances_and_tags[instance.id].append(value)
                # Always add the instance id
                instances_and_tags[instance.id].append(instance.id)

            server_count+=1

    cache.append(instances_and_tags)
    cache.append(instances_and_name)
    cache.append(instances_and_dns)

    pickle.dump(cache, cache_file_fh)
    cache_file_fh.close()

    if (server_count == 0):
        print >>sys.stderr, 'No servers found!'
        sys.exit(1)
    else:
        print >>sys.stderr, 'Cache populated - ' + str(server_count) + ' servers found'

def instance_search(search_list):

    cache_file_fh = open(cache_file, 'rb')

    cache = pickle.load(cache_file_fh)
    cache_file_fh.close()

    instances_and_tags=cache[0]
    instances_and_name=cache[1]
    instances_and_dns=cache[2]
    dict_of_sets={}
    found_instances=set()
    
    for keyword in search_list:
        keyword_string=str(keyword)
        for k, v in instances_and_tags.iteritems():
            for v_tag in v:
                match = re.search(keyword, v_tag)
                if match:
                    if keyword not in dict_of_sets:
                        dict_of_sets[keyword_string]=set([k])
                    else:
                        dict_of_sets[keyword_string].add(k)

    for k, v in dict_of_sets.iteritems():
        if len(v) > 0:
            if len(found_instances) == 0:
                found_instances=v
            else:
                found_instances.intersection_update(v)

    return found_instances, instances_and_name, instances_and_dns

def usage():
    print >>sys.stderr, 'Usage:'
    print >>sys.stderr, '    ' + sys.argv[0] + " tag1 tag2... \tConnect to EC2 instance searched for by tag(s)"
    print >>sys.stderr, '    ' + sys.argv[0] + " --update-cache\tUpdate the cache"
    sys.exit(1)

def main():

    index_selector={}
    target=None
    post_ssh_args=[]
    search_list=[]

    if (len(sys.argv) < 2):
        usage()

    # Catch the regular stuff like help and update-cache
    try:
        opts, args = getopt.getopt(sys.argv[1:], '', ['help', 'update-cache'])
    except getopt.GetoptError, err:
        print >>sys.stderr, str(err) 
        return 1

    for o, a in opts:
        if o in ('-h', '--help'):
            usage()
            sys.exit(0)
        elif o in ('--update-cache'):
            populate_cache()
            sys.exit(0)

    # Catch the rest as search strings until we meet something starting with a -
    for arg in sys.argv[1:]:
        if arg in [ '--help', '--update-cache' ]:
            usage()
            sys.exit(0)
        elif arg.startswith('-') or arg.startswith('--') or len(post_ssh_args) > 0:
            post_ssh_args.append(arg)
        elif len(post_ssh_args) == 0:
            search_list.append(arg.lower())

    if len(search_list) == 0:
        print 'No search words defined'
        sys.exit(1)
   
    check_cache()
    found_instances, instances_and_name, instances_and_dns=instance_search(search_list)

    if (len(found_instances) == 0):
        print 'No servers found'
        sys.exit(0)

    if (len(found_instances) > 1):
        print 'We found multiple servers - please choose' 

        for index, instance_id in enumerate(found_instances):
            if len(instances_and_dns[instance_id]) == 0:
                print "({0:<3} {1:<10} {2:<20} {3}".format(index+1, instance_id, instances_and_name[instance_id],  'stopped')
            else: 
                print "({0:<3} {1:<10} {2:<20} {3}".format(index+1, instance_id, instances_and_name[instance_id], instances_and_dns[instance_id])
            index_selector[index+1]=instances_and_dns[instance_id]
    
        try:
            selection = int(raw_input("Number: "))
            target=index_selector[selection]
        except (ValueError, IndexError, KeyError), e:
            print 'Invalid choice: ' + str(e)
            sys.exit(1)
        except:
            print 'Invalid choice!'
            sys.exit(1)
    else:
        instance_id=found_instances.pop()
        target=instances_and_dns[instance_id]

    # Check that public IP is available
    if target in ['', None]:
        print 'Could not determine hostname from instance id %s (%s)' % (instance_id, instances_and_name[instance_id])
        sys.exit(1)
        
    ssh_args = 'ssh' + ' ' + str(target) + ' ' + ' '.join(post_ssh_args)
    ssh_args = shlex.split(ssh_args)

    print 'Connecting to ' + target 
    subprocess.call(ssh_args)

if __name__ == "__main__":
    try:
        sys.exit(main())
    except (KeyboardInterrupt, SystemExit):
        sys.exit(0)
