#!/usr/bin/env python -u
import sys
import boto.ec2
import getopt
import subprocess
import threading
import Queue
import shlex
import re

# Create 3 global queues
"""
instanceid_and_tag
instanceid_and_dns
instanceid_and_name
"""
data_queues={'i_n_t' : None, 'i_n_d' : None, 'i_n_n' : None}

for queue in data_queues:
    data_queues[queue] = Queue.Queue()

def start_workers():
    regions = boto.ec2.regions()
    workers=[]

    for region in regions:
        t = threading.Thread(target=work_on_region, args=(region,))
        workers.append(t)
        t.setDaemon(True)
        t.start()

    return workers

def work_on_region(region ):

    i_n_t={}
    i_n_n={}
    i_n_d={}

    try:
        conn = region.connect()
    except:
        print >>sys.stderr, 'Failed to connect to ' + str(region.name)
        sys.exit(1)
    
    reservations = conn.get_all_instances()

    for reservation in reservations:
        for instance in reservation.instances:

            if instance.state == 'terminated':
                continue

            i_n_d[instance.id]=instance.public_dns_name

            # Lower all values in tag list
            i_n_t[instance.id] = map(lambda x: x.lower(), instance.tags.values())
            i_n_t[instance.id].append(instance.id)

            try:
                i_n_n[instance.id]=instance.tags.get('Name').lower()
            except:
                continue

    try:
        data_queues['i_n_t'].put(i_n_t)
        data_queues['i_n_n'].put(i_n_n)
        data_queues['i_n_d'].put(i_n_d)
    except:
        print >>sys.stderr, 'Failed to write to data queues'
        sys.exit(1)

def instance_search(search_list):

    # Dicts
    data_dicts={
        'i_n_t' : {},
        'i_n_n' : {},
        'i_n_d' : {},
    }

    for queue in data_queues:
        while data_queues[queue].qsize() > 0:
            try:
                data_dicts[queue].update(data_queues[queue].get())
            except Queue.Empty:
                print >>sys.stderr, 'Failed to read from ' + str(queue) + ' queue - empty' 
                sys.exit(1)
            except:
                print >>sys.stderr, 'Failed to read from ' + str(queue) + ' queue'
                sys.exit(1)

    print 'Searching through ' + str(len(data_dicts['i_n_d'])) + ' servers'

    dict_of_sets={}
    found_instances=set()
    
    for keyword in search_list:
        keyword_string=str(keyword)
        for k, v in data_dicts['i_n_t'].iteritems():
            for v_tag in v:
                match = re.search(keyword, v_tag)
                if match:
                    if keyword not in dict_of_sets:
                        dict_of_sets[keyword_string]=set([k])
                    else:
                        dict_of_sets[keyword_string].add(k)

    for k, v in dict_of_sets.iteritems():
        if len(v) > 0:
            if len(found_instances) == 0:
                found_instances=v
            else:
                found_instances.intersection_update(v)

    return found_instances, data_dicts['i_n_n'], data_dicts['i_n_d']

def usage():
    print >>sys.stderr, 'Usage:'
    print >>sys.stderr, '    ' + sys.argv[0] + " tag1 tag2... \tConnect to EC2 instance searched for by tag(s)"
    sys.exit(1)

def main():

    index_selector={}
    target=None
    post_ssh_args=[]
    search_list=[]

    if (len(sys.argv) < 2):
        usage()

    # Catch the regular stuff like help
    try:
        opts, args = getopt.getopt(sys.argv[1:], '', ['help'])
    except getopt.GetoptError, err:
        print >>sys.stderr, str(err) 
        return 1

    for o, a in opts:
        if o == '-h' or o  == '--help':
            usage()
            sys.exit(0)

    # Catch the rest as search strings until we meet something starting with a -
    for arg in sys.argv[1:]:
        if arg ==  '--help':
            usage()
            sys.exit(0)
        elif arg.startswith('-') or arg.startswith('--') or len(post_ssh_args) > 0:
            post_ssh_args.append(arg)
        elif len(post_ssh_args) == 0:
            search_list.append(arg.lower())

    # Spawn workers as fast as possible
    workers = start_workers()

    # Summon threads
    for thread in workers:
        thread.join()

    if len(search_list) == 0:
        print 'No search words defined'
        sys.exit(1)
   
    found_instances, i_n_n, i_n_d=instance_search(search_list)

    if (len(found_instances) == 0):
        print 'No servers found'
        sys.exit(0)

    if (len(found_instances) > 1):
        print 'We found multiple servers - please choose' 

        for index, instance_id in enumerate(found_instances):
            if len(i_n_d[instance_id]) == 0:
                print "({0:<3} {1:<10} {2:<20} {3}".format(index+1, instance_id, i_n_n[instance_id],  'stopped')
            else: 
                print "({0:<3} {1:<10} {2:<20} {3}".format(index+1, instance_id, i_n_n[instance_id], i_n_d[instance_id])
            index_selector[index+1]=i_n_d[instance_id]
    
        try:
            selection = int(raw_input("Number: "))
            target=index_selector[selection]
        except (KeyboardInterrupt):
            print '\nSee you..'
            sys.exit(1)
        except (ValueError, IndexError, KeyError), e:
            print '\nInvalid choice: ' + str(e)
            sys.exit(1)
        except:
            print '\nInvalid choice!'
            sys.exit(1)
    else:
        instance_id=found_instances.pop()
        target=i_n_d[instance_id]

    # Check that public IP is available
    if target in ['', None]:
        print 'Could not determine hostname from instance id %s (%s)' % (instance_id, i_n_n[instance_id])
        sys.exit(1)
        
    ssh_args = 'ssh' + ' ' + str(target) + ' ' + ' '.join(post_ssh_args)
    ssh_args = shlex.split(ssh_args)

    print 'Connecting to ' + target 
    subprocess.call(ssh_args)

if __name__ == "__main__":
    try:
        sys.exit(main())
    except (KeyboardInterrupt, SystemExit):
        sys.exit(0)
